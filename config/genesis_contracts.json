[
    {
        "name": "currency",
        "owner": "",
        "code": "__balances = Hash(default_value=0, contract='currency', name='balances')\n\n\ndef ____(vk: str):\n    __balances[vk] = 288090567\n\n\n@__export('currency')\ndef transfer(amount: float, to: str):\n    assert amount > 0, 'Cannot send negative balances!'\n    sender = ctx.caller\n    assert __balances[sender] >= amount, 'Not enough coins to send!'\n    __balances[sender] -= amount\n    __balances[to] += amount\n\n\n@__export('currency')\ndef balance_of(account: str):\n    return __balances[account]\n\n\n@__export('currency')\ndef allowance(owner: str, spender: str):\n    return __balances[owner, spender]\n\n\n@__export('currency')\ndef approve(amount: float, to: str):\n    assert amount > 0, 'Cannot send negative balances!'\n    sender = ctx.caller\n    __balances[sender, to] += amount\n    return __balances[sender, to]\n\n\n@__export('currency')\ndef transfer_from(amount: float, to: str, main_account: str):\n    assert amount > 0, 'Cannot send negative balances!'\n    sender = ctx.caller\n    assert __balances[main_account, sender\n        ] >= amount, 'Not enough coins approved to send! You have {} and are trying to spend {}'.format(\n        __balances[main_account, sender], amount)\n    assert __balances[main_account] >= amount, 'Not enough coins to send!'\n    __balances[main_account, sender] -= amount\n    __balances[main_account] -= amount\n    __balances[to] += amount\n"
    },
    {
        "name": "election_house",
        "owner": "",
        "code": "I = importlib\n__policies = Hash(contract='election_house', name='policies')\npolicy_interface = [I.Func('vote', args=('vk', 'obj')), I.Func('current_value')\n    ]\n\n\n@__export('election_house')\ndef register_policy(contract: str):\n    if __policies[contract] is None:\n        p = I.import_module(contract)\n        assert I.owner_of(p\n            ) == ctx.this, 'Election house must control the policy contract!'\n        assert I.enforce_interface(p, policy_interface\n            ), 'Policy contract does not follow the correct interface'\n        __policies[contract] = True\n    else:\n        raise Exception('Policy already registered')\n\n\n@__export('election_house')\ndef current_value_for_policy(policy: str):\n    assert __policies[policy] is not None, f'Invalid policy: {policy}.'\n    p = I.import_module(policy)\n    return p.current_value()\n\n\n@__export('election_house')\ndef vote(policy: str, value: Any):\n    assert __policies[policy] is not None, 'Invalid policy.'\n    p = I.import_module(policy)\n    p.vote(vk=ctx.caller, obj=value)\n"
    },
    {
        "name": "stamp_cost",
        "owner": "election_house",
        "code": "import election_house\n__S = Hash(contract='stamp_cost', name='S')\n\n\ndef ____(initial_rate: int=100, master_contract='masternodes',\n    delegate_contract='delegates', election_max_length=datetime.DAYS * 1):\n    __S['value'] = initial_rate\n    __S['master_contract'] = master_contract\n    __S['delegate_contract'] = delegate_contract\n    __S['election_max_length'] = election_max_length\n    __S['vote_count'] = 1\n    __reset_current_votes()\n\n\ndef __reset_current_votes():\n    __S['current_total'] = __S['value']\n\n\n@__export('stamp_cost')\ndef current_value():\n    return __S['value']\n\n\n@__export('stamp_cost')\ndef vote(vk: str, obj: int):\n    if __S['election_start'] is None:\n        total_nodes = len(election_house.current_value_for_policy(__S[\n            'master_contract'])) + len(election_house.\n            current_value_for_policy(__S['delegate_contract']))\n        __S['vote_count'] = 1\n        __S['min_votes_required'] = total_nodes * 2 \/\/ 3 + 1\n        __S['election_start'] = now\n        __S.clear('has_voted')\n        __reset_current_votes()\n        __tally_vote(vk, obj)\n    else:\n        __tally_vote(vk, obj)\n        if __election_is_over():\n            __update_value()\n            __S['election_start'] = None\n\n\ndef __update_value():\n    __S['value'] = int(__S['current_total'] \/ __S['vote_count']) or 1\n\n\ndef __election_is_over():\n    return __S['vote_count'] >= __S['min_votes_required'] or now - __S[\n        'election_start'] >= __S['election_max_length']\n\n\ndef __tally_vote(vk: str, obj: int):\n    __validate_vote(vk, obj)\n    __S['current_total'] += obj\n    __S['has_voted', vk] = True\n    __S['vote_count'] += 1\n\n\ndef __validate_vote(vk: str, obj: int):\n    assert vk in election_house.current_value_for_policy(__S['master_contract']\n        ) or vk in election_house.current_value_for_policy(__S[\n        'delegate_contract']), 'Not allowed to vote!'\n    assert type(obj) == int, 'Pass an int!'\n    assert obj > 0, 'No negatives!'\n    assert __S['value'] \/ 2 <= obj <= __S['value'] * 2, 'Out of range!'\n    assert __S['votes', vk] is None, 'Already voted!'\n"
    },
    {
        "name": "rewards",
        "owner": "election_house",
        "code": "import election_house\n__S = Hash(contract='rewards', name='S')\n\n\ndef ____(initial_split: list=[decimal('0.44'), decimal('0.44'), decimal(\n    '0.01'), decimal('0.01'), decimal('0.1')], master_contract=\n    'masternodes', delegate_contract='delegates', election_max_length=\n    datetime.DAYS * 1):\n    __S['value'] = initial_split\n    __S['master_contract'] = master_contract\n    __S['delegate_contract'] = delegate_contract\n    __S['election_max_length'] = election_max_length\n    __S['vote_count'] = 0\n    __reset_current_votes()\n\n\ndef __reset_current_votes():\n    __S['current_votes', 'masternodes'] = 0\n    __S['current_votes', 'delegates'] = 0\n    __S['current_votes', 'blackhole'] = 0\n    __S['current_votes', 'foundation'] = 0\n    __S['current_votes', 'developer'] = 0\n\n\n@__export('rewards')\ndef current_value():\n    return __S['value']\n\n\n@__export('rewards')\ndef vote(vk: str, obj: list):\n    if __S['election_start'] is None:\n        total_nodes = len(election_house.current_value_for_policy(__S[\n            'master_contract'])) + len(election_house.\n            current_value_for_policy(__S['delegate_contract']))\n        __S['vote_count'] = 0\n        __S['min_votes_required'] = total_nodes * 2 \/\/ 3 + 1\n        __S['election_start'] = now\n        __S.clear('has_voted')\n        __reset_current_votes()\n        __tally_vote(vk, obj)\n    else:\n        __tally_vote(vk, obj)\n        if __election_is_over():\n            __update_value()\n            __S['election_start'] = None\n\n\ndef __update_value():\n    masternode_votes = __S['current_votes', 'masternodes'] or 1\n    delegate_votes = __S['current_votes', 'delegates'] or 1\n    blackhole_votes = __S['current_votes', 'blackhole'] or 1\n    foundation_votes = __S['current_votes', 'foundation'] or 1\n    developer_votes = __S['current_votes', 'developer'] or 1\n    total_votes = (masternode_votes + delegate_votes + blackhole_votes +\n        foundation_votes + developer_votes)\n    mn = masternode_votes \/ total_votes\n    dl = delegate_votes \/ total_votes\n    bh = blackhole_votes \/ total_votes\n    fd = foundation_votes \/ total_votes\n    dv = developer_votes \/ total_votes\n    __S['value'] = [mn, dl, bh, fd, dv]\n\n\ndef __election_is_over():\n    return __S['vote_count'] >= __S['min_votes_required'] or now - __S[\n        'election_start'] >= __S['election_max_length']\n\n\ndef __tally_vote(vk: str, obj: list):\n    __validate_vote(vk, obj)\n    a, b, c, d, e = obj\n    __S['current_votes', 'masternodes'] += a\n    __S['current_votes', 'delegates'] += b\n    __S['current_votes', 'blackhole'] += c\n    __S['current_votes', 'foundation'] += d\n    __S['current_votes', 'developer'] += e\n    __S['has_voted', vk] = True\n    __S['vote_count'] += 1\n\n\ndef __validate_vote(vk: str, obj: list):\n    assert vk in election_house.current_value_for_policy(__S['master_contract']\n        ) or vk in election_house.current_value_for_policy(__S[\n        'delegate_contract']), 'Not allowed to vote!'\n    assert type(obj) == list, 'Pass a list!'\n    assert len(obj) == 5, 'Must have 5 elements!'\n    s = 0\n    for o in obj:\n        assert int(o) >= 0, 'No non-negative numbers!'\n        s += o\n    assert s == 100, 'Elements must add to 100!'\n    assert __S['has_voted', vk] is None, 'VK has already voted!'\n"
    },
    {
        "name": "upgrade",
        "owner": "",
        "code": "import election_house\nELECTION_WINDOW = datetime.WEEKS * 1\n__upgrade_state = Hash(contract='upgrade', name='upgrade_state')\n__has_voted = Hash(default_value=False, contract='upgrade', name='has_voted')\n\n\ndef ____():\n    __upgrade_state['locked'] = False\n    __upgrade_state['consensus'] = False\n    __upgrade_state['votes'] = 0\n    __upgrade_state['voters'] = 0\n\n\ndef __start_vote(cilantro_branch_name: str, contracting_branch_name: str,\n    pepper: str):\n    __upgrade_state['locked'] = True\n    __upgrade_state['pepper'] = pepper\n    __upgrade_state['cilantro_branch_name'] = cilantro_branch_name\n    __upgrade_state['contracting_branch_name'] = contracting_branch_name\n    __upgrade_state['votes'] = 0\n    __upgrade_state['voters'] = len(election_house.current_value_for_policy\n        ('masternodes')) + len(election_house.current_value_for_policy(\n        'delegates'))\n    __upgrade_state['started'] = now\n\n\ndef __is_valid_voter(address: str):\n    if address in election_house.current_value_for_policy('masternodes'):\n        return True\n    elif address in election_house.current_value_for_policy('delegates'):\n        return True\n    return False\n\n\n@__export('upgrade')\ndef vote(**kwargs):\n    assert not __has_voted[ctx.caller], 'Cannot vote twice!'\n    assert __is_valid_voter(ctx.caller), 'Invalid voter!'\n    assert not __upgrade_state['consensus'], 'Consensus already achieved!'\n    if __upgrade_state['started'] is not None and now - __upgrade_state[\n        'started'] > ELECTION_WINDOW:\n        __upgrade_state.clear()\n        __has_voted.clear()\n    if not __upgrade_state['locked']:\n        __start_vote(**kwargs)\n        __upgrade_state['votes'] += 1\n        __has_voted[ctx.caller] = True\n    elif __upgrade_state['votes'] + 1 >= __upgrade_state['voters'] * 2 \/\/ 3:\n        __upgrade_state['consensus'] = True\n        __has_voted.clear()\n    else:\n        __upgrade_state['votes'] += 1\n        __has_voted[ctx.caller] = True\n"
    },
    {
        "name": "foundation",
        "owner": "",
        "code": "import currency\n__owner = Variable(contract='foundation', name='owner')\n\n\ndef ____(vk: str):\n    __owner.set(vk)\n\n\n@__export('foundation')\ndef withdraw(amount: float):\n    assert amount > 0, 'Cannot send negative balances!'\n    assert ctx.caller == __owner.get(), 'Not owner!'\n    currency.transfer(amount, ctx.caller)\n\n\n@__export('foundation')\ndef change_owner(vk: str):\n    assert ctx.caller == __owner.get(), 'Not owner!'\n    __owner.set(vk)\n"
    }
]